syntax=Other.Implementation;SFP--1;CWE-398
sysunrecog=;SFP--1;CWE--1;

#/*
#  ** Null Dereferences (Manual Section 2)
#  */

preproc=Other;SFP--1;CWE--1

null=;SFP-7;CWE-476
#misuses of null pointer
#A possibly null pointer is misused (sets nullderef, nullpass, nullref, nullassign, and nullstate).

nullderef=;SFP-7;CWE-476
#possible dereferencce of null pointer
#A possibly null pointer is dereferenced.  Value is 
#either the result of a function which may return null 
#(in which case, code should check it is not null), or a 
#global, parameter or structure field declared with the 
#null qualifier.

nullpass=;SFP-7;CWE-476
#possibly null pointer passed as formal with no null annotation
#A possibly null pointer is passed as a parameter corresponding to 
#a formal parameter with no /*@null@*/ annotation.  If NULL 
#may be used for this parameter, add a /*@null@*/ annotation 
#to the function parameter declaration.

nullret=;SFP-7;CWE-476
#possibly null pointer returned as result with no null annotation
#Function returns a possibly null pointer, but is not declared 
#using /*@null@*/ annotation of result.  If function may 
#return NULL, add /*@null@*/ annotation to the return 
#value declaration.

nullstate=;SFP-7;CWE-476
#possibly null pointer reachable from a reference with no null annotation
#A possibly null pointer is reachable from a parameter or global 
#variable that is not declared using a /*@null@*/ annotation.

nullassign=;SFP--1;CWE-684
#inconsistent assignment or initialization involving null pointer
#A reference with no null annotation is assigned or initialized 
#to NULL.  Use /*@null@*/ to declare the reference as 
#a possibly null pointer.
 
nullinit=;SFP--1;CWE-684
#inconsistent initialization involving null pointer
#A reference with no null annotation is initialized 
#to NULL.  Use /*@null@*/ to declare the reference as 
#a possibly null pointer.





#  /*
#  ** Undefined Values (Section 3)
#  */
 
usedef=;SFP-1;CWE-457
#use before definition
#An rvalue is used that may not be initialized to a value on some execution path.

mustdefine=;SFP-1;CWE-457
#out storage not defined before return or scope exit
#An out parameter or global is not defined before control is transferred.

uniondef=;SFP-1;CWE-456
#at least one field of a union must be defined
#No field of a union is defined. Generally, one field of a union is 
#expected to be defined.

compdef=;SFP-1;CWE-456
#parameter, return value or global completely defined
#Storage derivable from a parameter, return value or global is 
#not defined. Use /*@out@*/ to denote passed or returned 
#storage which need not be defined.

fullinitblock=;SFP-1;CWE-456
#initializer sets all fields
#Initializer does not set every field in the structure.

initallelements=;SFP-1;CWE-456
#initializer defines all array elements
#Initializer does not define all elements of a declared array.

initsize=;SFP--1;CWE-684
#initializer defines extra array elements
#Initializer block contains more elements than the size of a declared array.

impouts=;SFP--1;CWE-684
#pointer parameters to unspecified functions may be implicit out parameters






#  /*
#  ** Types (Section 4)
#  */

incondefs=;SFP--1;CWE-710
#A function, variable or constant is redefined with a different type.

matchfields=;SFP--1;CWE-710
#A struct, union or enum type is redefined with inconsistent fields or members.

fcnderef=;SFP--1;CWE-398
#dereferencce of a function type
#A function type is dereferenced.  The ANSI standard allows this 
#because of implicit conversion of function designators, however the 
#dereference is unnecessary. 

realcompare=Other.Design;SFP--1;CWE-480
#dangerous equality comparison between reals (dangerous because of inexact 
#floating point representations)
#Two real (float, double, or long double) values are compared 
#directly using == or != primitive. 
#This may produce unexpected results since floating point 
#representations are inexact. Instead, compare the difference to 

realrelatecompare=Other.Design;SFP--1;CWE-480
#possibly dangerous relational comparison between reals (dangerous because of inexact 
#floating point representations)
#Two real (float, double, or long double) values are compared 
#directly using < or >. 
#This may produce unexpected results since floating point 
#representations are inexact. Instead, compare the difference to 

unsignedcompare=;SFP--1;CWE-398
#comparison using <, <=, >= between an unsigned integral and zero constant
#An unsigned value is used in a comparison with zero in a way that is either a bug or confusing.

ptrarith=;SFP--1;CWE-480
#arithmetic involving pointer and integer
#Pointer arithmetic using pointer and integer.

nullptrarith=;SFP-1;CWE-704
#arithmetic involving possibly null pointer and integer
#Pointer arithmetic using a possibly null pointer and integer.

ptrcompare=;SFP--1;CWE-480
#comparison between pointer and number
#A pointer is compared to a number.

strictops=;SFP--1;CWE-480
#primitive operation does not type check strictly
#A primitive operation does not type check strictly.

bitwisesigned=;SFP--1;CWE-480
#a bitwise logical operator does not have unsigned operands
#An operand to a bitwise operator is not an unsigned values.  This 
#may have unexpected results depending on the signed 
#representations.
 
shiftnegative=;SFP--1;CWE-480
#a shift right operand may be negative
#The right operand to a shift operator may be negative (behavior undefined).

shiftimplementation=;SFP--1;CWE-480
#a shift left operand may be negative
#The left operand to a shift operator may be negative (behavior is implementation-defined).

sizeoftype=;SFP-10;CWE-467
#sizeof operator has a type argument
#Operand of sizeof operator is a type. (Safer to use expression, 
#int *x = sizeof (*x); instead of sizeof (int).) 

sizeofformalarray=;SFP-10;CWE-467
#sizeof operator has an array formal parameter argument
#Operand of a sizeof operator is a function parameter declared as 
#an array.  The value of sizeof will be the size of a pointer to the 
#element type, not the number of elements in the array.

fixedformalarray=;SFP--1;CWE-710
#formal parameter of type array is declared with size
#A formal parameter is declared as an array with size.  The size of the array 
#is ignored in this context, since the array formal parameter is treated 
#as a pointer.

incompletetype=;SFP--1;CWE-710
#formal parameter has an incomplete type
#A formal parameter is declared with an incomplete type.

formalarray=;SFP-1;CWE-469
#formal parameter is an array
#A formal parameter is declared as an array.  This can be confusing, since 
#a formal array parameter is treated as a pointer.







#  /*
#  ** Booleans (4.2)
#  */
  
likelybool=Other.Implementation;SFP--1;CWE-710
#type name is probably a boolean type but does not match default 
#boolean type name, \bool\ and alternate name is not set
#Use the -booltype, -boolfalse and -booltrue flags to change the 
#name of the default boolean type.
 
boolcompare=;SFP--1;CWE-398
#comparison between bools (dangerous because of multiple true values)
#Two bool values are compared directly using a C primitive. This 
#may produce unexpected results since all non-zero values are 
#considered true, so different true values may not be equal. 
#The file bool.h (included in splint/lib) provides bool_equal 
#for safe bool comparisons.
 
boolops=;SFP--1;CWE-480
#primitive operation (!, && or ||) does not has a boolean argument
#The operand of a boolean operator is not a boolean. Use +ptrnegate 
#to allow ! to be used on pointers.

ptrnegate=;SFP--1;CWE-480
#allow ! to be used on pointer operand
#The operand of ! operator is a pointer.
  
predassign=;SFP-1;CWE-481
#condition test (if, while or for) is an assignment
#The condition test is an assignment expression. Probably, you mean 
#to use == instead of =. If an assignment is intended, add an 
#extra parentheses nesting (e.g., if ((a = b)) ...) to suppress 
#this message.

predbool=;SFP--1;CWE-480
#type of condition test (if, while or for) not bool (sets predboolint, 
#predboolptr and predboolothers)
#Test expression type is not boolean.

predboolothers=;SFP--1;CWE-480

predboolint=;SFP-1;CWE-704
#type of condition test (if, while or for) is an integral type
#Test expression type is not boolean or int.
 
predboolptr=;SFP-1;CWE-704
#type of condition test (if, while or for) is a pointer
#Test expression type is not boolean.

predboolOthers=;SFP--1;CWE-398
#type of condition test (if, while or for) not bool, int or pointer
#Test expression type is not boolean. 







#  /*
#  ** 4.3 Abstract types
#  */

abstract=;SFP--1;CWE-710
#data abstraction barriers
#An abstraction barrier is broken. If necessary, use /*@access <type>@*/ to allow access to an abstract type.

abstractcompare=;SFP--1;CWE-480
#object equality comparison on abstract type operands
#An object comparison (== or !=) is used on operands of abstract type.

numabstract=;SFP--1;CWE-710
#data abstraction barriers
#An abstraction barrier involving a numabstract type is broken. If necessary, use /*@access <type>@*/ to allow access to a numabstract type.

numabstractcast=;SFP--1;CWE-710
#numeric literal cast to numabstract type
#A numeric literal is cast to a numabstract type.

numabstractlit=;SFP--1;CWE-710
#numeric literal can used as numabstract type
#To allow a numeric literal to be used as a numabstract type, use +numabstractlit.

numabstractindex=;SFP--1;CWE-398
#a numabstract type can be used to index an array
#To allow numabstract types to index arrays, use +numabstractindex.

numabstractprint=;SFP-1;CWE-704
#a numabstract value is printed using %d format code
#A numabstract value is printed usind %d format code in a printf.

impabstract=;SFP--1;CWE--1
#assume user type definitions are abstract (unless /*@concrete@*/ is used)


charindex=;SFP--1;CWE-398


#  /* 4.3.1 Access */

accessmodule=;SFP--1;CWE--1
#allow access to abstract types in definition module
#The representation of an abstract type defined in <M>.<x> is 
#accessible anywhere in a file named <M>.<y>. 

#accessfile=;SFP--1;CWE--1
#allow access to abstract types by file name convention
#The representation of an abstract type named <t> is 
#accessible anywhere in a file named <t>.<x>. 

accessczech=;SFP--1;CWE--1
#allow access to abstract types by czech naming convention
#The representation of an abstract type named <t> is accessible 
#in the definition of a function or constant named <t>_<name>

accessslovak=;SFP--1;CWE--1
#allow access to abstract types by slovak naming convention
#The representation of an abstract type named <t> is accessible 
#in the definition of a function or constant named <t><Name>

accessczechoslovak=;SFP--1;CWE--1
#allow access to abstract types by czechoslovak naming convention
#The representation of an abstract type named <t> is accessible 
#in the definition of a function or constant named <t>_<name> or <t><Name>

accessall=;SFP--1;CWE--1
#set accessmodule, accessfile and accessczech
#Sets accessmodule, accessfile and accessczech







#  /* 4.3.2 Mutability */


mutrep=;SFP--1;CWE-710
#representation of mutable type has sharing semantics
#LCL semantics requires that a mutable type exhibits sharing semantics. 
#In order for objects to be shared a indirection is necessary in the representation. 
#A mutable type may be represented by a pointer or an abstract mutable type. Handles 
#into static data are fine, too, but will generate this error message unless it is suppressed.






#  /*
#  ** Memory Management (5)
#  */


#  /* Deallocation Errors */


mustfreefresh=;SFP-38;CWE-401
#freshly allocated storage not released before return or scope exit
#A memory leak has been detected. Storage allocated locally 
#is not released before the last reference to it is lost.

mustfreeonly=;SFP-38;CWE-401
#only storage not released before return or scope exit
#A memory leak has been detected. Only-qualified storage is not released before the last 
#reference to it is lost.

mustfree=;SFP-38;CWE-401
#fresh or only storage not released before return or scope exit (sets mustfreefresh and mustfreeonly)
#A memory leak has been detected.

usereleased=;SFP-7;CWE-416
#storage used after release
#Memory is used after it has been released (either by passing 
#as an only param or assigning to an only global).

strictusereleased=;SFP-7;CWE-416
#element used after it may have been released
#Memory (through fetch) is used after it may have been released 
#(either by passing as an only param or assigning to an only global).

compdestroy=;SFP-38;CWE-401
#all only references derivable from void pointer out only parameter are released
#A storage leak due to incomplete deallocation of a structure or deep 
#pointer is suspected. Unshared storage that is reachable from 
#a reference that is being deallocated has not yet been deallocated. 
#Splint assumes when an object is passed 
#as an out only void pointer that the outer object will be 
#deallocated, but the inner objects will not.


branchstate=;SFP--1;CWE--1
#storage has inconsistent states of alternate paths through a branch
#The state of a variable is different depending on which branch 
#is taken. This means no annotation can sensibly be applied 
#to the storage.

strictbranchstate=;SFP--1;CWE--1
#storage through array fetch has inconsistent states of alternate 
#paths through a branch
#The state of a variable through an array fetch is different depending 
#on which branch is taken. This means no annotation can sensibly be applied 
#to the storage.
 
compmempass=;SFP--1;CWE-710
#actual parameter matches alias kind of formal parameter completely 
#Storage derivable from a parameter does not match the alias kind 
#expected for the formal parameter.

stackref=;SFP-1;CWE-562
#external reference to stack-allocated storage is created
#A stack reference is pointed to by an external reference when the 
#function returns. The stack-allocated storage is destroyed 
#after the call, leaving a dangling reference.
 
memtrans=;SFP--1;CWE-710
#memory transfer errors (sets all *trans flags)
#Memory is transferred in a way that violates annotations.

dependenttrans=;SFP--1;CWE-710
#dependent transfer errors
#Dependent storage is transferred to a non-dependent reference.

newreftrans=;SFP--1;CWE--1
#new reference transfer to reference counted reference
#A new reference is transferred to a reference counted reference.

onlytrans=;SFP--1;CWE-701
#only storage transferred to non-only reference (memory leak)
#The only reference to this storage is transferred to another 
#reference (e.g., by returning it) that does not have the 
#only annotation. This may lead to a memory leak, since the 
#new reference is not necessarily released.

onlyunqglobaltrans=;SFP-38;CWE-401
#only storage transferred to an unqualified global or 
#static reference (memory leak)
#The only reference to this storage is transferred to another 
#reference that does not have an aliasing annotation. 
#This may lead to a memory leak, since the 
#new reference is not necessarily released.

ownedtrans=;SFP--1;CWE-710
#owned storage transferred to non-owned reference (memory leak)
#The owned reference to this storage is transferred to another 
#reference (e.g., by returning it) that does not have the 
#owned annotation. This may lead to a memory leak, since the 
#new reference is not necessarily released.

freshtrans=;SFP--1;CWE-710
#fresh storage transferred to non-only reference (memory leak)
#Fresh storage (newly allocated in this function) is transferred 
#in a way that the obligation to release storage is not 
#propagated.  Use the /*@only@*/ annotation to indicate 
#the a return value is the only reference to the returned 
#storage.

sharedtrans=;SFP--1;CWE-710
#shared storage transferred to non-shared reference
#Shared storage is transferred to a non-shared reference. The other 
#reference may release storage needed by this reference.

temptrans=;SFP--1;CWE-710
#temp storage transferred to non-temporary reference
#Temp storage (associated with a formal parameter) is transferred 
#to a non-temporary reference. The storage may be released 
#or new aliases created.

kepttrans=;SFP--1;CWE-710
#kept storage transferred to non-temporary reference
#storage is transferred 
#to a non-temporary reference after being passed as keep parameter. The storage may be released 
#or new aliases created.

keeptrans=;SFP--1;CWE-710
#keep storage transferred inconsistently
#Keep storage is transferred inconsistently --- either in a way 
#that may add a new alias to it, or release it.

immediatetrans=;SFP--1;CWE-398
#an immediate address (result of &) is transferred inconsistently
#An immediate address (result of & operator) is transferred 
#inconsistently.

refcounttrans=;SFP--1;CWE-398
#reference counted storage is transferred in an inconsistent way
#Reference counted storage is transferred in a way that may not 
#be consistent with the reference count.

statictrans=;SFP--1;CWE-398
#static storage is transferred in an inconsistent way
#Static storage is transferred in an inconsistent way.

unqualifiedtrans=;SFP--1;CWE-398
#unqualified storage is transferred in an inconsistent way
#Unqualified storage is transferred in an inconsistent way.

staticinittrans=;SFP--1;CWE-398
#static storage is used as an initial value in an inconsistent way
#Static storage is used as an initial value in an inconsistent way.

unqualifiedinittrans=;SFP--1;CWE-398
#unqualified storage is used as an initial value in an inconsistent way
#Unqualified storage is used as an initial value in an inconsistent way.

readonlytrans=;SFP--1;CWE-398
#report memory transfer errors for initializations to read-only string literals
#A read-only string literal is assigned to a non-observer reference.

passunknown=;SFP--1;CWE-710
#passing a value as an un-annotated parameter clears its annotation





#  /* 5.3 Implicit Memory Annotations */

readonlystrings=;SFP-12;CWE-590
#string literals are read-only (error if one is modified or released)
#String literals are read-only. An error is reported 
#if a string literal may be modified or released.

memimp=;SFP--1;CWE--1
#memory errors for unqualified storage
 
paramimptemp=;SFP--1;CWE--1
#assume unannotated parameter is temp
 
globimponly=;SFP--1;CWE--1
#assume unannotated global storage is only
 
retimponly=;SFP--1;CWE--1
#assume unannotated returned storage is only
 
structimponly=;SFP--1;CWE--1
#assume unannotated structure field is only

specglobimponly=;SFP--1;CWE--1
#assume unannotated global storage is only

specretimponly=;SFP--1;CWE--1
#assume unannotated returned storage is only

specstructimponly=;SFP--1;CWE--1
#assume unannotated structure field is only






#  /* Reference Counting */

#  /*
#  ** 6. Sharing
#  */

#  /* 6.1 Aliasing warnings */

aliasunique=;SFP--1;CWE-710
#unique parameter is aliased
#A unique or only parameter is aliased by some other parameter or visible global.

mayaliasunique=;SFP--1;CWE-710
#unique parameter may be aliased
#A unique or only parameter may be aliased by some other parameter or visible global.

mustnotalias=;SFP--1;CWE-710
#temp storage aliased at return point or scope exit
#An alias has been added to a temp-qualifier parameter or global that is visible externally when the function returns. If the aliasing is needed, use the /*@shared@*/ annotation to indicate that new aliases to the parameter may be created.

retalias=;SFP-1;CWE-562
#function returns alias to parameter or global
#The returned value shares storage with a parameter or global. If a parameter is to be returned, use the returned qualifier. If the result is not modified, use the observer qualifier on the result type. otherwise, exposed can be used, but limited checking is done. 0, 0





#  /* Global aliasing */

globalias=;SFP--1;CWE-710
#function returns with global aliasing external state (sets 
#checkstrictglobalias, checkedglobalias, checkmodglobalias and 
#uncheckedglobalias)
#A global variable aliases externally-visible state when the function returns.

checkstrictglobalias=;SFP--1;CWE-710
#function returns with a checkstrict global aliasing external state
#A global variable aliases externally-visible state when the function returns.

checkedglobalias=;SFP--1;CWE-710
#function returns with a checked global aliasing external state
#A global variable aliases externally-visible state when the function returns.

checkmodglobalias=;SFP--1;CWE-710
#function returns with a checkmod global aliasing external state
#A global variable aliases externally-visible state when the function returns.

uncheckedglobalias=;SFP--1;CWE-710
#function returns with an unchecked global aliasing external state
#A global variable aliases externally-visible state when the function returns.






#  /* 6.2 Exposure */
 
exposetrans=;SFP-25;CWE-454
#exposure transfer errors
#Exposed storage is transferred to a non-exposed, non-observer reference.

observertrans=;SFP-25;CWE-454
#observer transfer errors
#Observer storage is transferred to a non-observer reference.

repexpose=;SFP-25;CWE-454
#abstract representation is exposed (sets assignexpose, retexpose, and castexpose)
#The internal representation of an abstract type is visible to the 
#caller. This means clients may have access to a pointer 
#into the abstract representation.

retexpose=;SFP-25;CWE-454
#abstract representation is exposed (return values only)
#The return value shares storage with an instance of an abstract 
#type. This means clients may have access to a pointer into 
#the abstract representation. Use the observer qualifier to 
#return exposed storage that may not be modified by the 
#client. Use the exposed qualifier to return modifiable 
#(but not deallocatable) exposed storage (dangerous).

assignexpose=;SFP-25;CWE-454
#abstract representation is exposed (assignments only)
#Storage internal to the representation of an abstract type is 
#assigned to an external pointer. This means clients may 
#have access to a pointer into the abstract representation. 
#If the external pointer is a parameter, the exposed qualifier 
#can be used to allow the assignment, however, this is 
#considered dangerous programming practice.

castexpose=;SFP-25;CWE-454
#abstract representation is exposed through a cast
#Storage internal to the representation of an abstract type is exposed 
#through a type cast. This means clients may have access to a 
#pointer into the abstract representation.

redundantsharequal=;SFP--1;CWE-710
#declaration uses observer qualifier that is always true
#A declaration of an immutable object uses a redundant observer qualifier.

misplacedsharequal=;SFP--1;CWE-710
#declaration of unsharable storage uses sharing annotation
#A declaration of an unsharable object uses a sharing annotation.






#  /*
#  ** 7. Function Interfaces
#  */

#  /* 7.1  Modifications */

mods=Other.Implementation;SFP--1;CWE-710
#unspecified modification of caller-visible state
#An externally-visible object is modified by a function, but not 
#listed in its modifies clause.

mustmod=Other.Implementation;SFP--1;CWE-710
#specified modification is not detected
#An object listed in the modifies clause is not modified by the 
#implementation of the function. The modification may not 
#be detected if it is done through a call to an unspecified 
#function.

modobserver=Other.Implementation;SFP--1;CWE-710
#possible modification of observer storage
#Storage declared with observer is possibly modified. Observer 
#storage may not be modified.

modobserveruncon=Other.Implementation;SFP--1;CWE-710
#possible modification of observer storage through unconstrained call
#Storage declared with observer may be modified through a call to an 
#unconstrained function.

modinternalstrict=Other.Implementation;SFP--1;CWE-710
#possible modification of internal storage through function call
#A function that modifies internalState is called from a function that 
#does not list internalState in its modifies clause

modunspec=Other.Implementation;SFP--1;CWE-710
#modification in unspecified functions (sets modnomods, 
#modglobunspec and modstrictglobsunspec)

modnomods=Other.Implementation;SFP--1;CWE-710
#modification in a function with no modifies clause
#An externally-visible object is modified by a function with no 
#/*@modifies@*/ comment. The /*@modifies ... @*/ control 
#comment can be used to give a modifies list for an 
#unspecified function.

moduncon=Other.Implementation;SFP--1;CWE-710
#possible modification through a call to an unconstrained function
#An unconstrained function is called in a function body where 
#modifications are checked. Since the unconstrained function 
#may modify anything, there may be undetected modifications in 
#the checked function.

modunconnomods=Other.Implementation;SFP--1;CWE-710
#possible modification through a call to an unconstrained function in 
#a function with no modifies clause
#An unconstrained function is called in a function body where 
#modifications are checked. Since the unconstrained function 
#may modify anything, there may be undetected modifications in 
#the checked function.

globsimpmodsnothing=Other.Implementation;SFP--1;CWE-710
#functions declared with a globals list but no modifies clause are 
#assumed to modify nothing
#An implicit modifies nothing clause is assumed for a function 
#declared with a globals list but not modifies clause.

modsimpnoglobs=Other.Implementation;SFP--1;CWE-710
#functions declared with a modifies clause but no globals list 
#are assumed to use no globals
#An implicit empty globals list is assumed for a function 
#declared with a modifies clause but no globals list.






#  /*
#  ** Globals
#  */

globstate=;SFP--1;CWE-684
#returns with global in inconsistent state (null or undefined)
#A global variable does not satisfy its annotations when control is transferred.


globuse=;SFP--1;CWE-710
#global listed for a function not used
#A global variable listed in the function's globals list is not used 
#in the body of the function.

internalglobs=;SFP--1;CWE-710
#use of internalState
#A called function uses internal state, but the globals list for the 
#function being checked does not include internalState

internalglobsnoglobs=;SFP--1;CWE-710
#use of internalState (in function with no globals list)
#A called function uses internal state, but the function being checked 
#has no globals list

warnmissingglobs=;SFP--1;CWE-710
#global variable used in modifies clause is not listed in globals list
#A global variable is used in the modifies clause, but it is not listed in 
#the globals list.  The variable will be added to the globals list.
 
warnmissingglobsnoglobs=;SFP--1;CWE-710
#global variable used in modifies clause in a function with no globals list
#A global variable is used in the modifies clause, but the function 
#has no globals list.  The variable will be added to the globals list.

globnoglobs=;SFP--1;CWE-710
#use of checked global in a function with no globals list or specification
#A specified global variable is used in the function, but not listed 
#in its globals list. Without +globnoglobs, only globals 
#declared with /*@checkedstrict@*/ will produce use 
#errors in functions without globals 
#lists. The /*@globals ... @*/ control comment can be used to give 
#a globals list for an unspecified function.

modglobs=;SFP--1;CWE-710
#undocumented modification of a checked global variable
#A checked global variable is modified by the function, but not listed in 
#its modifies clause.

modglobsnomods=;SFP--1;CWE-710
#undocumented modification of a checked global variable in a function 
#declared with no modifies clause
#A checked global variable is modified by the function, but not listed in 
#its modifies clause.

modstrictglobsnomods=;SFP--1;CWE-710
#undocumented modification of a strict checked global variable in a 
#function declared with no modifies clause
#A checked global variable is modified by the function, but not listed in 
#its modifies clause.

modglobsunchecked=;SFP--1;CWE-710
#undocumented modification of an unchecked checked global variable
#An unchecked global variable is modified by the function, but not listed in 
#its modifies clause.








#  /*
#  ** State Clauses
#  */

#  /*
#  ** 8. Control Flow 
#  */

#  /* 8.1 Execution */

noret=;SFP--1;CWE-398
#path with no return detected in non-void function
#There is a path through a function declared to return a value on 
#which there is no return statement. This means the execution 
#may fall through without returning a meaningful result to 
#the caller.

emptyret=;SFP--1;CWE--1
#empty return in function declared to return value

alwaysexits=;SFP-1;CWE-570
#loop predicate always exits 





#  /* 8.2 Undefined Behavior */
  
evalorder=;SFP--1;CWE-710
#code has unspecified or implementation-dependent behavior 
#because of order of evaluation
#Code has unspecified behavior. 
#Order of evaluation of function parameters or subexpressions 
#is not defined, so if a value is used and modified in different 
#places not separated by a sequence point constraining 
#evaluation order, then the result of the expression is 
#unspecified. 

evalorderuncon=;SFP--1;CWE-88
#code involving call to unspecified function has undefined or implementation-dependent behavior
#Code involving a call to function with no modifies or globals clause 
#may have undefined or implementation-dependent behavior (Splint assumes the 
#unconstrained call may modify any reachable state or use any global). Add a 
#specification for the function. 






#  /* 8.3 Problematic Control Structures */

#  /* 8.3.1 Infinite Loops */
 
infloops=;SFP--1;CWE-835
#likely infinite loop is detected
#This appears to be an infinite loop. Nothing in the body of the 
#loop or the loop test modifies the value of the loop test. 
#Perhaps the specification of a function called in the loop 
#body is missing a modification.

infloopsuncon=;SFP--1;CWE-835
#likely infinite loop is detected (may result from unconstrained function)
#This appears to be an infinite loop. Nothing in the body of the 
#loop or the loop test modifies the value of the loop test. 
#There may be a modification through a call to an unconstrained 
#function, or an unconstrained function in the loop test may use 
#a global variable modified by the loop body.






#  /* 8.3.2 Switches */

casebreak=;SFP-4;CWE-484
#non-empty case in a switch without preceding break
#Execution falls through from the previous case (use /*@fallthrough@*/ to mark fallthrough cases). 0, 0
 
misscase=;SFP--1;CWE-230
#switch on enum type missing case for some value
#Not all values in an enumeration are present as cases in the switch.

firstcase=;SFP--1;CWE-710
#first statement in switch is not a case
#The first statement after a switch is not a case.

duplicatecases=;SFP--1;CWE-697
#duplicate cases in switch
#Duplicate cases in switch.






#  /* 8.3.3 Deep Breaks */
 
deepbreak=;SFP--1;CWE-710
#break inside nested while or for or switch
#A break statement appears inside the body of a nested while, for or 
#switch statement. Sets looploopbreak, loopswitchbreak, 
#switchloopbreak, switchswitchbreak, and looploopcontinue.

looploopbreak=;SFP--1;CWE-710
#break inside nested while or for
#A break statement appears inside the body of a nested while or for 
#statement. This is perfectly reasonable code, but check that 
#the break is intended to break only the inner loop. The 
#break statement may be preceded by /*@innerbreak@*/ to suppress 
#the message for this break only.

switchloopbreak=;SFP--1;CWE-710
#break in loop inside switch
#A break statement appears inside the body of a while or for 
#statement within a switch. This is perfectly reasonable code, but check that 
#the break is intended to break only the inner loop. The 
#break statement may be preceded by /*@loopbreak@*/ to suppress 
#the message for this break only.

loopswitchbreak=;SFP--1;CWE-710
#break in switch inside loop
#A break statement appears inside a switch statement within a while or 
#for loop. This is perfectly reasonable code, but check that 
#the break is intended to break only the inner loop. The 
#break statement may be preceded by /*@switchbreak@*/ to suppress 
#the message for this break only.

switchswitchbreak=;SFP--1;CWE-710
#break in switch inside switch
#A break statement appears inside a switch statement within another 
#switch statement. This is perfectly reasonable code, but check that 
#the break is intended to break only the inner switch. The 
#break statement may be preceded by /*@innerbreak@*/ to suppress 
#the message for this break only.

looploopcontinue=;SFP--1;CWE-710
#continue inside nested loop
#A continue statement appears inside a loop within a loop. 
#This is perfectly reasonable code, but check that 
#the continue is intended to continue only the inner loop. The 
#continue statement may be preceded by /*@innercontinue@*/ to suppress 
#the message for this continue only.




#  /* 8.3.4 Loop and If Bodies */
 
whileempty=;SFP--1;CWE-398
#a while statement has no body
#While statement has no body.

whileblock=;SFP--1;CWE-710
#the body of a while statement is not a block
#While body is a single statement, not a compound block.

forempty=;SFP--1;CWE-398
#a for statement has no body
#For statement has no body.

forblock=;SFP--1;CWE-710
#the body of a for statement is not a block
#Loop body is a single statement, not a compound block.

ifempty=;SFP--1;CWE-710
#an if statement has no body
#If statement has no body.

ifblock=;SFP--1;CWE-710
#the body of an if statement is not a block
#If body is a single statement, not a compound block.

allempty=;SFP--1;CWE-710
#an if, while or for statement has no body (sets ifempty, 
#whileempty and forempty

allblock=;SFP--1;CWE-710
#the body of an if, while or for statement is not a block 
#(sets ifblock, whileblock and forblock)
#Body is a single statement, not a compound block.





#  /* 8.3.5 Complete Logic */

elseifcomplete=;SFP--1;CWE-710
#if ... else if chains must have final else
#There is no final else following an else if construct.





#  /* 8.4 Suspicious Statements */
 
unreachable=;SFP-2;CWE-561
#unreachable code detected
#This code will never be reached on any possible execution.





#  /* 8.4.1 Statements with No Effects */
  
noeffect=;SFP--1;CWE-398
#statement with no effect
#Statement has no visible effect --- no values are modified.

noeffectuncon=;SFP--1;CWE-710
#statement with no effect (except possibly through call to 
#unconstrained function)
#Statement has no visible effect --- no values are modified. It may 
#modify something through a call to an unconstrained function.





#  /* 8.4.2 Ignored Return Values */
 
retval=;SFP-4;CWE-252
#return value ignored (sets retvalint, retvalbool and retvalother)
#Result returned by function call is not used. If this is intended, 
#   cast result to (void) to eliminate message.

retvalother=;SFP-4;CWE-252
#return value of type other than bool or int ignored
#Result returned by function call is not used. If this is intended, 
#   can cast result to (void) to eliminate message.

retvalbool=;SFP-4;CWE-252
#return value of manifest type bool ignored
#Result returned by function call is not used. If this is intended, 
#   can cast result to (void) to eliminate message.

retvalint=;SFP-4;CWE-252
#return value of type int ignored
#Result returned by function call is not used. If this is intended, 
#   can cast result to (void) to eliminate message.





#  /*
#  ** 9. Buffer Sizes 
#  */
 
nullterminated=;SFP-11;CWE-170
#misuse of nullterminated allocation
#A possibly non-nullterminated string/memory is used/referenced as a nullterminated one.

bounds=;SFP-8;CWE-119
#memory bounds checking (sets boundsread and boundswrite)
#Memory read or write may be out of bounds of allocated storage.
 
likelybounds=;SFP-8;CWE-119
#memory bounds checking (sets likelyboundsread and likelyboundswrite)
#Memory read or write may be out of bounds of allocated storage.
 
likelyboundsread=;SFP-8;CWE-119
#likely out of bounds read
#A memory read references memory beyond the allocated storage.

likelyboundswrite=;SFP-8;CWE-119
#likely buffer overflow from an out of bounds write
#A memory write may write to an address beyond the allocated buffer.

boundsread=;SFP-8;CWE-125
#possible out of bounds read
#A memory read references memory beyond the allocated storage.

boundswrite=;SFP--1;CWE-787
#possible buffer overflow from an out of bounds write
#A memory write may write to an address beyond the allocated buffer.





/*drl7x added 6/18/01 */

checkpost=;SFP--1;CWE-710
#unable to verify predicate in ensures clause
#The function implementation may not satisfy a post condition given in an ensures clause.
 
impboundsconstraints=;SFP--1;CWE--1
#generate implicit constraints for functions



#   /* evans added 2003-06-08 */

allocmismatch=;SFP-1;CWE-681
#type conversion involves storage of non-divisble size





#  /*
#  ** 10. Extensible Checking 
#  */


statetransfer=;SFP--1;CWE-682
#storage has been transfered with invalid state
#Transfer violates user-defined state rules.

statemerge=;SFP--1;CWE-372
#control paths merge with storage in incompatible states
#Control path merge violates user-defined state merge rules.





#  /* 
#  ** 11. Macros 
#  */
 
macroredef=;SFP--1;CWE-710
#macro redefined
#A macro is defined in more than one place.

macrounrecog=;SFP--1;CWE--1
#unrecognized identifier in macro
#An unrecognized identifier appears in a macro. If the identifier 
#is defined before the macro is used, then this is okay.





#  /* 11.1 Constant Macros */
 
macroconstdecl=;SFP--1;CWE-710
#non-parameterized macro without prototype or specification
#Macro constant has no declaration. Use /*@constant ...@*/ to 
#declare the macro.
 
macroconstdistance=;SFP--1;CWE-710
#macro constant name does not match nearby name
#Macro constant name does matches name of a previous declaration, but they are not near each other.





#  /* 11.2 Function-like Macros */
 
macrostmt=;SFP--1;CWE-710
#macro definition is syntactically not equivalent to function
#A macro is defined in a way that may cause syntactic problems. 
#If the macro returns a value, use commas to separate expressions; 
#otherwise, use do  <macro body>  while (FALSE) construct.

macroempty=;SFP--1;CWE-398
#macro definition for is empty
#A macro definition has no body.

macroparams=;SFP--1;CWE-710
#macro parameter not used exactly once
#A macro parameter is not used exactly once in all possible 
#invocations of the macro. To behave like a function, 
#each macro parameter must be used exactly once on all 
#invocations of the macro so that parameters with 
#side-effects are evaluated exactly once. Use /*@sef@*/ to 
#denote parameters that must be side-effect free.

macroret=;SFP--1;CWE-710
#return statement in macro body
#The body of a macro declared as a function uses a return statement. 
#This exhibits behavior that 
#could not be implemented by a function. 

macroassign=;SFP--1;CWE-710
#assignment to a macro parameter
#A macro parameter is used as the left side of an 
#assignment expression. This exhibits behavior that 
#could not be implemented by a function. 

macroparens=;SFP--1;CWE-710
#macro parameter used without parentheses (in potentially dangerous context)
#A macro parameter is used without parentheses. This could be 
#dangerous if the macro is invoked with a complex expression 
#and precedence rules will change the evaluation inside the macro.

macrodecl=;SFP--1;CWE-710
#macro without prototype or specification (sets macrofcndecl and macroconstdecl)
#Argument checking cannot be done well for macros without prototypes 
#or specifications, since the types of the arguments are unknown.

macrofcndecl=;SFP--1;CWE-710
#parameterized macro without prototype or specification
#Function macro has no declaration.






#  /* 11.2.1 Side Effect Free Parameters */
 
sefparams=;SFP--1;CWE-710
#a parameter with side-effects is passed as a sef parameter
#An actual parameter corresponding to a sef parameter may have a side-effect.

sefuncon=;SFP--1;CWE-710
#a parameter with unconstrained side-effects is passed as a sef parameter
#An actual parameter corresponding to a sef parameter involves a call 
#to a procedure with no modifies clause that may have a side-effect.






#  /* 11.3 Controlling Macro Checking */
 
constmacros=;SFP--1;CWE--1
#check all macros without parameter lists as constants
#Every non-parameterized macro (not preceded by /*@notfunction@*/) 
#is checked as a constant.

fcnmacros=;SFP--1;CWE--1
#check all macros with parameter lists as functions
#Every parameterized macro (not preceded by /*@notfunction@*/) 
#is checked as a function.
 
allmacros=;SFP--1;CWE--1
#sets fcnmacros and constmacros
#All macros (not preceded by /*@notfunction@*/) are checked as functions or 
#constants depending on whether or not they have parameter lists.

libmacros=;SFP--1;CWE--1
#check all macros with declarations in library as functions
#Every macro declared in the load library is checked.
 
specmacros=;SFP--1;CWE--1
#check all macros corresponding to specified functions or constants
#Every macro declared a specification file is checked.

macromatchname=;SFP--1;CWE-710
#macro definition does not match iter or constant declaration
#A iter or constant macro is defined using a different name from the 
#one used in the previous syntactic comment

nextlinemacros=;SFP--1;CWE-710
#the line after a constant or iter declaration must be a macro definition
#A constant or iter declaration is not immediately followed by a macro definition.





#  /* 11.4 Iterators */
 
iterbalance=;SFP--1;CWE-710
#iter is not balanced with end_<iter>

iteryield=;SFP--1;CWE-710
#iter yield parameter is inappropriate

hasyield=;SFP--1;CWE-710
#iter declaration has no yield parameters
#An iterator has been declared with no parameters annotated with 
#yield. This may be what you want, if the iterator is meant 
#to do something a fixed number of times, but returns no 
#information to the calling context. Probably, a parameter 
#is missing the yield annotation to indicate that it is 
#assigned a value in the calling context.






#  /*
#  ** 12. Naming Conventions 
#  */
 
namechecks=;SFP--1;CWE--1
#controls name checking without changing other settings





#  /* 12.1.1 Czech Names */
 
czech=;SFP--1;CWE-710
#czech naming convention (sets accessczech, czechfunctions, czechvars, 
#czechconstants, czechenums, and czechmacros)
#Name is not consistent with Czech naming convention.

czechfcns=;SFP--1;CWE-710
#czech naming convention violated in a function or iterator declaration
#Function or iterator name is not consistent with Czech naming convention.

czechvars=;SFP--1;CWE-710
#czech naming convention violated in a variable declaration
#Variable name is not consistent with Czech naming convention. 
 
czechmacros=;SFP--1;CWE-710
#czech naming convention violated in an expanded macro name
#Expanded macro name is not consistent with Czech naming convention. 

czechconsts=;SFP--1;CWE-710
#czech naming convention violated in a constant declaration
#Constant name is not consistent with Czech naming convention. 

czechtypes=;SFP--1;CWE-710
#czech naming convention violated in a user-defined type definition
#Type name is not consistent with Czech naming convention. Czech type 
#names must not use the underscore character. 




#  /* 12.1.2 Slovak Names */
  
slovak=;SFP--1;CWE-710
#slovak naming convention violated
#Name is not consistent with Slovak naming convention.

slovakfcns=;SFP--1;CWE-710
#slovak naming convention violated in a function or iterator declaration
#Function or iterator name is not consistent with Slovak naming convention. 

slovakmacros=;SFP--1;CWE-710
#slovak naming convention violated in an expanded macro name
#Expanded macro name is not consistent with Slovak naming convention. 
 
slovakvars=;SFP--1;CWE-710
#slovak naming convention violated in a variable declaration
#Variable name is not consistent with Slovak naming convention.
  
slovakconsts=;SFP--1;CWE-710
#slovak naming convention violated in a constant declaration
#Constant name is not consistent with Slovak naming convention. 

slovaktypes=;SFP--1;CWE-710
#slovak naming convention violated in a use-defined type definition
#Type name is not consistent with Slovak naming convention. Slovak type 
#names may not include uppercase letters. 





#  /* 12.1.3 Czechoslovak Names */

czechoslovak=;SFP--1;CWE-710
#czech or slovak naming convention violated
#Name is not consistent with either Czech or Slovak naming convention.

czechoslovakfcns=;SFP--1;CWE-710
#czechoslovak naming convention violated in a function or iterator declaration
#Function name is not consistent with Czechoslovak naming convention.

czechoslovakmacros=;SFP--1;CWE-710
#czechoslovak naming convention violated in an expanded macro name
#Expanded macro name is not consistent with Czechoslovak naming convention.
 
czechoslovakvars=;SFP--1;CWE-710
#czechoslovak naming convention violated in a variable declaration
#Variable name is not consistent with Czechoslovak naming convention.
 
czechoslovakconsts=;SFP--1;CWE-710
#czechoslovak naming convention violated in a constant declaration
#Constant name is not consistent with Czechoslovak naming convention.
 
czechoslovaktypes=;SFP--1;CWE-710
#czechoslovak naming convention violated in a user-defined type definition
#Type name is not consistent with Czechoslovak naming convention. Czechoslovak 
#type names may not include uppercase letters or the underscore character.




#  /* 12.2 Namespace Prefixes */

macrovarprefix=;SFP--1;CWE-710
#set namespace prefix for variables declared in a macro body
#A variable declared in a macro body does not start with the macrovarprefix.

macrovarprefixexclude=;SFP--1;CWE-710
#the macrovarprefix may not be used for non-macro variables
#A variable declared outside a macro body starts with the macrovarprefix.
 
tagprefix=;SFP--1;CWE-710
#set namespace prefix for struct, union and enum tags
#A tag identifier does not start with the tagprefix.
 
tagprefixexclude=;SFP--1;CWE-710
#the tagprefix may not be used for non-tag identifiers
#An identifier that is not a tag starts with the tagprefix.

enumprefix=;SFP--1;CWE-710
#set namespace prefix for enum members
#An enum member does not start with the enumprefix.

enumprefixexclude=;SFP--1;CWE-710
#the enumprefix may not be used for non-enum member identifiers
#An identifier that is not an enum member starts with the enumprefix.

filestaticprefix=;SFP--1;CWE-710
#set namespace prefix for file static declarations
#A file-static identifier does not start with the filestaticprefix.

filestaticprefixexclude=;SFP--1;CWE-710
#the filestaticprefix may not be used for identifiers that are not file static
#An identifier that is not file static starts with the filestaticprefix.
 
globalprefix=;SFP--1;CWE-710
#set namespace prefix for global variables
#A global variable does not start with the globalprefix
 
globalprefixexclude=;SFP--1;CWE-710
#the globalprefix may not be used for non-global identifiers
#An identifier that is not a global variable starts with the globalprefix.

typeprefix=;SFP--1;CWE-710
#set namespace prefix for user-defined types
#A user-defined type does not start with the typeprefix

typeprefixexclude=;SFP--1;CWE-710
#the typeprefix may not be used for identifiers that are not type names
#An identifier that is not a type name starts with the typeprefix.

externalprefix=;SFP--1;CWE-710
#set namespace prefix for external identifiers
#An external identifier does not start with the externalprefix
 
externalprefixexclude=;SFP--1;CWE-710
#the externalprefix may not be used for non-external identifiers
#An identifier that is not external starts with the externalprefix.

localprefix=;SFP--1;CWE-710
#set namespace prefix for local variables
#A local variable does not start with the localprefix

localprefixexclude=;SFP--1;CWE-710
#the localprefix may not be used for non-local identifiers
#An identifier that is not a local variable starts with the localprefix.

uncheckedmacroprefix=;SFP--1;CWE-710
#set namespace prefix for unchecked macros
#An unchecked macro name does not start with the uncheckedmacroprefix

uncheckedmacroprefixexclude=;SFP--1;CWE-710
#the uncheckmacroprefix may not be used for identifiers that are not 
#unchecked macros
#An identifier that is not the name of an unchecked macro 
#starts with the uncheckedmacroprefix.

constprefix=;SFP--1;CWE-710
#set namespace prefix for constants
#A constant does not start with the constantprefix
 
constprefixexclude=;SFP--1;CWE-710
#the constprefix may not be used for non-constant identifiers
#An identifier that is not a constant starts with the constantprefix.

iterprefix=;SFP--1;CWE-710
#set namespace prefix for iterators
#An iter does not start with the iterator prefix

iterprefixexclude=;SFP--1;CWE-710
#the iterprefix may not be used for non-iter identifiers
#An identifier that is not a iter starts with the iterprefix.
 
protoparamprefix=;SFP--1;CWE-710
#set namespace prefix for parameters in function prototype declarations
#A parameter name in a function prototype declaration does not start with the 
#declaration parameter prefix






#  /* 12.3 Naming Restrictions */

isoreserved=;SFP--1;CWE-710
#external name conflicts with name reserved for system or standard library
#External name is reserved for system use by ISO C99 standard.

cppnames=;SFP--1;CWE-710
#external or internal name is a C++ keyword or reserved word
#External name is a C++ keyword or reserved word. 
#This could lead to problems if the 
#code is compiled with a C++ compiler.

isoreservedinternal=;SFP--1;CWE-710
#internal name conflicts with name reserved for system or standard library
#Internal name is reserved for system in ISO C99 standard (this should not be necessary unless you are worried about C library implementations that violate the standard and use macros).

distinctexternalnames=;SFP--1;CWE-710
#external name is not distinguishable from another external name using 
#the number of significant characters
#An external name is not distinguishable from another external name 
#using the number of significant characters. According to 
#ANSI Standard (3.1), an implementation may only consider the first 6 
#characters significant, and ignore alphabetical case 
#distinctions (ISO C99 requires 31). The 
#+externalnamelen <n> flag may be used to change the number 
#of significant characters, and -externalnamecaseinsensitive to make 
#alphabetical case significant in external names.

externalnamelen=;SFP--1;CWE-710
#set the number of significant characters in an external name
#Sets the number of significant characters in an external name (default is 6 for old 
#ANSI89 limit, C99 requires 31). 
#Sets +distinctexternalnames.

externalnamecaseinsensitive=;SFP--1;CWE-710
#alphabetic comparisons for external names are case-insensitive
#Make alphabetic case insignificant in external names. By ANSI89 
#standard, case need not be significant in an external name. 
#If +distinctexternalnames is not set, sets 
#+distinctexternalnames with unlimited external name length.

distinctinternalnames=;SFP--1;CWE-710
#internal name is not distinguishable from another internal name using 
#the number of significant characters
#An internal name is not distinguishable from another internal name 
#using the number of significant characters. According to 
#ANSI89 Standard (3.1), an implementation may only consider the first 31 
#characters significant (ISO C99 specified 63). The 
#+internalnamelen <n> flag changes the number 
#of significant characters, -internalnamecaseinsensitive to makes 
#alphabetical case significant, and 
#+internalnamelookalike to make similar-looking characters 
#non-distinct.



internalnamelookalike=;SFP--1;CWE-710
#lookalike characters match in internal names
#Set whether similar looking characters (e.g., \1\ and \l\) 
#match in internal names.

protoparamname=;SFP--1;CWE-710
#a parameter in a function prototype has a name
#A parameter in a function prototype has a name.  This is dangerous, 
#since a macro definition could be visible here.

protoparammatch=;SFP--1;CWE-710
#the name of a parameter in a function prototype and corresponding 
#declaration must match (after removing the protoparamprefix 
#A parameter in a function definition does not have the same name as 
#the corresponding in the declaration of the function after 
#removing the protoparamprefix 

protoparamprefixexclude=;SFP--1;CWE-710
#the protoparamprefix may not be used for non-declaraction parameter identifiers
#An identifier that is not a parameter name in a function prototype 
#starts with the protoparamprefix.






#  /*
#  ** 13. Completeness 
#  */

#  /* 13.1 Unused Declarations */

topuse=;SFP--1;CWE-398
#declaration at top level not used
#An external declaration not used in any source file.
 
exportlocal=;SFP--1;CWE-398
#a declaration is exported but not used outside this module
#A declaration is exported, but not used outside this module. 
#Declaration can use static qualifier.

exportheader=;SFP--1;CWE-398
#a declaration is exported but does not appear in a header file
#A declaration is exported, but does not appear in a header file.

exportheadervar=;SFP-2;CWE-563
#a variable declaration is exported but does not appear in a header file
#A variable declaration is exported, but does not appear in a header 
#file. (Used with exportheader.)

fielduse=;SFP-2;CWE-561
#field of structure type not used
#A field is present in a structure type but never used. Use /*@unused@*/ in front of field declaration to suppress message.

enummemuse=;SFP-2;CWE-561
#member of an enum type not used
#A member of an enum type is never used.

constuse=;SFP-2;CWE-563
#constant declared but not used
#A constant is declared but not used. Use unused in the constant declaration to suppress message.

fcnuse=;SFP-2;CWE-561
#function declared but not used
#A function is declared but not used. Use /*@unused@*/ in front of function header to suppress message.

paramuse=;SFP--1;CWE-398
#function parameter not used 
#A function parameter is not used in the body of the function. If the argument is needed for type compatibility or future plans, use /*@unused@*/ in the argument declaration.

typeuse=;SFP-2;CWE-561
#type declared but not used
#A type is declared but not used. Use /*@unused@*/ in front of typedef to suppress messages.

varuse=;SFP-2;CWE-563
#variable declared but not used
#A variable is declared but never used. Use /*@unused@*/ in front 
#of declaration to suppress message.

unusedspecial=;SFP-2;CWE-561
#unused declaration in special file (corresponding to .l or .y file)







#  /* 13.2 Complete Programs */

declundef=;SFP-2;CWE-561
#function or variable declared but never defined
#A function or variable is declared, but not defined in any source code file.

specundef=;SFP-2;CWE-561
#function or variable specified but never defined
#A function or variable is declared in an .lcl file, but not defined in any source code file.

specundecl=;SFP-2;CWE-561
#function or variable specified but never declared in a source file
#A function or variable is declared in an .lcl file, but not declared 
#in any source code file.


needspec=;SFP--1;CWE--1
#information in specifications is not also included in syntactic comments
#There is information in the specification that is not duplicated 
#in syntactic comments. Normally, this is not an 
#error, but it may be useful to detect it to make 
#sure checking incomplete systems without the specifications will 
#still use this information.






#  /*
#  ** 14. Libraries and Header File Inclusion 
#  */

#  /* 14.1 Standard Libraries */
 
warnposixheaders=;SFP-2;CWE-561
#a POSIX header is included, but the POSIX library is not used
#Header name matches a POSIX header, but the POSIX library is not selected.


usevarargs=;SFP--1;CWE-710
#non-standard <varargs.h> included
#Header <varargs.h> is not part of ANSI Standard. 
#Should use <stdarg.h> instead.

caseinsensitivefilenames=;SFP--1;CWE-710
#file names are case insensitive (file.h and FILE.H are the same file)




#  /* Prototypes */

noparams=;SFP--1;CWE--1
#function declaration has no parameter list
#A function declaration does not have a parameter list.

oldstyle=;SFP--1;CWE-398
#old style function definition
#Function definition is in old style syntax. Standard prototype 
#syntax is preferred.






#  /*
#  ** System functions
#  */

maintype=;SFP--1;CWE-710
#type of main does not match expected type
#The function main does not match the expected type.

exitarg=;SFP-3;CWE-474
#argument to exit has implementation defined behavior
#The argument to exit should be 0, EXIT_SUCCESS or EXIT_FAILURE
 
shadow=;SFP--1;CWE-710
#declaration reuses name visible in outer scope
#An outer declaration is shadowed by the local declaration.

incondefslib=;SFP--1;CWE-398
#function, variable or constant defined in a library is redefined with inconsistent type
#A function, variable or constant previously defined in a library is 
#redefined with a different type.

overload=;SFP--1;CWE-398
#library function overloaded
#A function, variable or constant defined in the library is redefined 
#with a different type.

nestedextern=;SFP--1;CWE-398
#an extern declaration is inside a function scope
#An extern declaration is used inside a function scope.
 
redecl=;SFP--1;CWE-398
#function or variable redeclared
#A function or variable is declared in more than one place. This is 
#not necessarily a problem, since the declarations are consistent.

redef=;SFP--1;CWE-398
#function or variable redefined
#A function or variable is redefined. One of the declarations should use extern.

imptype=;SFP--1;CWE-710
#variable declaration has unknown (implicitly int) type
#A variable declaration has no explicit type.  The type is implicitly int.

exportany=;SFP--1;CWE-710
#variable, function or type exported but not specified
#A variable, function or type is exported, but not specified.

exportfcn=;SFP--1;CWE-710
#function exported but not specified
#A function is exported, but not specified.

exportmacro=;SFP--1;CWE-710
#expanded macro exported but not specified
#A macro is exported, but not specified.

exporttype=;SFP--1;CWE-710
#type definition exported but not specified
#A type is exported, but not specified.
 
exportvar=;SFP--1;CWE-710
#variable exported but not specified
#A variable is exported, but not specified.

exportconst=;SFP--1;CWE-710
#constant exported but not specified
#A constant is exported, but not specified.

exportiter=;SFP--1;CWE-710
#constant exported but not specified
#A constant is exported, but not specified.






#  /*
#  ** Limits 
#  */

type=;SFP-1;CWE-704
#type mismatch
#Types are incompatible.
 
stringliteraltoolong=;SFP-8;CWE-119
#string literal too long for character array
#A string literal is assigned to a char array too small to hold it.

stringliteralnoroomfinalnull=;SFP-11;CWE-170
#string literal leaves no room for null terminator
#A string literal is assigned to a char array that is not big enough to hold the final null terminator.  This may not be a problem because a null character has been explictedly included in the string literal using an escape sequence

stringliteralnoroom=;SFP-11;CWE-170
#string literal leaves no room for null terminator
#A string literal is assigned to a char array that is not big enough to hold the null terminator.

stringliteralsmaller=;SFP-8;CWE-119
#string literal is smaller than the char array it is assigned to
#A string literal is assigned to a char array that smaller than the string literal needs.

enummembers=;SFP-1;CWE-704
#enum members must be int values
#Type of initial values for enum members must be int.

formattype=;SFP--1;CWE-628
#type-mismatch in parameter corresponding to format code in a printf or scanf-like function
#Type of parameter is not consistent with corresponding code in format string.

formatconst=;SFP-24;CWE-134
#format parameter is not a string constant (hence variable arguments cannot be typechecked)
#Format parameter is not known at compile-time.  This can lead to security vulnerabilities because the arguments cannot be type checked.

formatcode=;SFP-24;CWE-134
#invalid format code in format string for printf or scanf-like function
#Format code in a format string is not valid.

forwarddecl=;SFP--1;CWE--1
#forward declarations of pointers to abstract representation match abstract type
 
voidabstract=;SFP--1;CWE-398
#void * matches pointers to abstract types, casting ok (dangerous)
#A pointer to void is cast to a pointer to an abstract type (or vice versa).

castfcnptr=;SFP-1;CWE-704
#a pointer to a function is cast to a pointer to void (or vice versa)
#A pointer to a function is cast to (or used as) a pointer to void (or vice versa).

unrecog=;SFP--1;CWE--1
#unrecognized identifier
#Identifier used in code has not been declared.

annotationerror=;SFP--1;CWE-546
#annotation is used in inconsistent location
#A declaration uses an invalid annotation.

commenterror=;SFP--1;CWE-546
#inconsistent syntactic comment
#A syntactic comment is used inconsistently.








#  /*
#  ** Use Warnings
#  */

bufferoverflow=;SFP-8;CWE-120
#possible buffer overflow vulnerability
#Use of function that may lead to buffer overflow.

bufferoverflowhigh=;SFP-8;CWE-120
#likely buffer overflow vulnerability
#Use of function that may lead to buffer overflow.
 
implementationoptional=;SFP--1;CWE-710
#declarator is implementation optional (ISO99 does not require an implementation to provide it)
#Use of a declarator that is implementation optional, not required by ISO99.
 
legacy=;SFP--1;CWE-710
#legacy declaration in Unix Standard
#Use of a declarator that is marked as a legacy entry in the Unix Standard.

multithreaded=;SFP--1;CWE-663
#function is not reentrant
#Non-reentrant function should not be used in multithreaded code.

portability=;SFP-3;CWE-474
#function may have undefined behavior
#Use of function that may have implementation-dependent behavior.

superuser=;SFP--1;CWE-710
#function is restricted to superusers
#Call to function restricted to superusers.

toctou=;SFP-20;CWE-367
#possible time of check, time of use vulnerability
#Possible time of check, time of use vulnerability.

unixstandard=;SFP--1;CWE-710
#function is not required in Standard UNIX Specification
#Use of function that need not be provided by UNIX implementations






#  /*
#  ** Syntactic comments
#  */

unrecogcomments=;SFP--1;CWE-546
#stylized comment is unrecognized
#Word after a stylized comment marker does not correspond to a 
#stylized comment.








#  /*
#  ** Comments
#  */
 
continuecomment=;SFP--1;CWE-546
#line continuation marker (\\) in comment before */ on same line
#A line continuation marker (\\) appears inside a comment on the same 
#line as the comment close. Preprocessors should handle this 
#correctly, but it causes problems for some preprocessors.

slashslashcomment=;SFP--1;CWE-546
#use of // comment 
#A // comment is used.  ISO C99 allows // comments, but earlier standards did not.

nestcomment=;SFP--1;CWE-546
#comment begins inside comment 
#A comment open sequence (/*) appears within a comment.  This usually 
#means an earlier comment was not closed.